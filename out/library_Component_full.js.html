<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: library/Component/full.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: library/Component/full.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React from 'react';
import {pop, bindComponent, mergeOptions} from '../../core/navigation';
import {Text, View} from '../UI';
import {BackHandler} from '../BackHandler';
import {StatusBar} from '../StatusBar';
import {Theme} from '../Theme';

const rend = () => null;

let propsWix = {};
/**
 * @param {Object} self компонент подписи
 * @param {Object} options параметры компонента
 * @param {Boolean} options.isBack флаг который указывает возможно ли осуществление обработки кнопки бек
 * @param {String} options.statusBar ('light','dark','hide') указывает использовать светлый статус бар или же оставить темный статус бар  или вообще срыть
 * @param {Function} options.onFocusedScreen функция обработки фокусировки на экран (возвращает true or false в зависимости от фокусировки)
 * @param {Object} options.propsScreen  пропса которую необходимо прокинуть в открывающийся экран (по умолчанию прокидывается все пропса)
 * @param {Function} options.styles функция возвращаюзаяя стиль компонента
 */
export default (self, {isBack = true, statusBar, onFocusedScreen, propsScreen, styles}) => {
	bindComponent(self);
	const nameScreen = self.props.componentId;

	const handleBackPress = () => {
		if (isBack) {
			pop(nameScreen);
			return true;
		}
		return true;
	};

	const setStatusBar = () => {
		if (!statusBar) {
			statusBar = propsWix.statusBar;
		}
		switch (statusBar) {
			case 'light':
				StatusBar.setLigthTranslucent();
				break;
			case 'dark':
				StatusBar.setDarkTranslucent();
				break;
			case 'hide':
				StatusBar.hide();
				break;
			default:
				StatusBar.setDarkTranslucent();
				break;
		}
	};

	const iosSwipeBack = () => {
		mergeOptions(nameScreen, {
			popGesture: isBack,
		});
	};

	self.onBack = function() {
		pop(nameScreen);
	};

	self.updateTheme = theme => {
		Theme.setTheme(theme);
		self.forceUpdate();
		self.styles = styles ? Theme.createStyles(styles) : {};
	};

	self.componentDidAppear = () => {
		setStatusBar();
		iosSwipeBack();
		self.__proto__.componentDidAppear &amp;&amp; self.__proto__.componentDidAppear.bind(self)();

		// Логика при установки фокуса на экрана

		// console.log('componentDidAppear', self);
		// Фокусировка экрана
		onFocusedScreen !== undefined
			? onFocusedScreen(true)
			: self.props.onFocusedScreen &amp;&amp; self.props.onFocusedScreen(true);

		self.props = {...self.props, ...propsWix};
	};

	self.componentDidDisappear = () => {
		self.__proto__.componentDidDisappear &amp;&amp; self.__proto__.componentDidDisappear.bind(self)();
		// Логика при снятии фокуса с экрана
		// Фокусировка экрана

		onFocusedScreen !== undefined
			? onFocusedScreen(false)
			: self.props.onFocusedScreen &amp;&amp; self.props.onFocusedScreen(false);

		// Прокидывание пропсы
		propsWix = {};
		propsWix = {
			...propsWix,
			statusBar: statusBar ? undefined : statusBar,
			...(propsScreen || self.props),
		};
	};

	self.componentDidMount = () => {
		self.__proto__.componentDidMount &amp;&amp; self.__proto__.componentDidMount.bind(self)();
		// console.log('componentDidMount');
		// Логика при монтировании
		BackHandler.addEventListener('hardwareBackPress', handleBackPress);
		StatusBar.setDarkTranslucent();
	};

	self.componentWillUnmount = () => {
		self.__proto__.componentWillUnmount &amp;&amp; self.__proto__.componentWillUnmount.bind(self)();
		// Логика при размонтровании
		BackHandler.removeEventListener('hardwareBackPress', handleBackPress);
	};

	self.componentWillUpdate = () => {
		self.__proto__.componentWillUpdate &amp;&amp; self.__proto__.componentWillUpdate.bind(self)();
		// console.log('componentWillUpdate');
	};

	self.componentWillMount = () => {
		self.__proto__.componentWillMount &amp;&amp; self.__proto__.componentWillMount.bind(self)();
		self.styles = styles ? Theme.createStyles(styles) : {};
		// console.log('componentWillMount');
	};

	// self.render = () => {
	// 	return (
	// 		&lt;>
	// 			{rend()}
	// 			{self.__proto__.render.bind(self)()}
	// 		&lt;/>
	// 	);
	// };
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-App.html">App</a></li><li><a href="module-Navigation.html">Navigation</a></li><li><a href="module-Onboarding.html">Onboarding</a></li><li><a href="module-Playground.html">Playground</a></li><li><a href="module-Rest.html">Rest</a></li><li><a href="module-Utils.html">Utils</a></li></ul><h3>Classes</h3><ul><li><a href="AnalyticService.html">AnalyticService</a></li><li><a href="Icon.html">Icon</a></li><li><a href="Spacer.html">Spacer</a></li><li><a href="Text.html">Text</a></li><li><a href="View.html">View</a></li></ul><h3>Global</h3><ul><li><a href="global.html#initModules">initModules</a></li><li><a href="global.html#initRoutes">initRoutes</a></li><li><a href="global.html#onLinking">onLinking</a></li><li><a href="global.html#refreshToken">refreshToken</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Apr 18 2019 16:09:22 GMT+0300 (Москва, стандартное время)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
